# Coment√°rios sobre o desafio e o processo de desenvolvimento:

---

## ü•¥ Principais dificuldades:

- Antes de come√ßar o desenvolvimento, precisei entender melhor o que o desafio pedia e por onde eu poderia come√ßar. 
Como algumas coisas n√£o estavam muito clara para mim, precisei de um tempo para entender melhor o problema, estudar e
planejar. 

- Precisei estudar o b√°sico do Flask para que conseguisse utilizar o framework para criar uma API RESTful. Iniciei 
tentando construir um front-end, mas percebi que iria levar um tempo consider√°vel para isso e n√£o iria entregar os
requisitos que foram solicitados de fato; ent√£o decidi que isso poderia ficar para um outro momento.

- **Minhas requisi√ß√µes para o TJCE foram um grande empecilho para finalizar a solu√ß√£o**. Antes mesmo de crawlear
os portais de 2¬™ inst√¢ncia, passei dias buscando solu√ß√µes para corrigir o problema, pois acreditava que isso poderia
ocorrer quando passasse para os portais de 2¬∫ grau e, al√©m disso, tamb√©m poderia acontecer em outras m√°quinas e 
comprometer a pessoa que fosse vir a utilizar a API que desenvolvi.

    Tentei utilizar bibliotecas alternativas √† [Requests](https://requests.readthedocs.io/en/latest/), como a urllib3, mas sem sucesso. Busquei enriquecer um 
pouco mais a requisi√ß√£o, criando uma sess√£o com o Session e passando headers que pudessem ajudar a evitar a suspeita de
que as requisi√ß√µes estavam sendo feitas por um rob√¥. Tamb√©m cheguei a cogitar que pudesse ser algo relacionado ao meu
sistema operacional; ent√£o rodei o c√≥digo em ambos os sistemas que tenho √† minha disposi√ß√£o: Windows 10 e Linux 
(Ubuntu 22 LTS). Apesar disso, o problema ainda persistia.

  A fim de investigar um pouco mais as possibilidades, pedi para um amigo testar a mesma request que eu  estava tentando
fazer e, curiosamente, ele conseguiu realizar sem maiores problemas. Ent√£o, pensei na possibilidade de ser algo 
relacionado √† minha rede e testei uma conex√£o atrav√©s de uma rede 4G; mas sem sucesso. 

- Para al√©m do [retorno 421](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/421) (como esse n√£o √© um dos c√≥digos de retornos mais comuns e achei bastante espec√≠fico, 
precisei dar uma r√°pida pesquisada sobre), logo abaixo est√° um dos erros mais frequentes que encontrei:

    ```commandline
    {SSLError}HTTPSConnectionPool(host='esaj.tjce.jus.br', port=443): Max retries exceeded with 
    url: /cpopg/show.do?processo.numero=0070337-91.2008.8.06.0001
    (Caused by SSLError(SSLZeroReturnError(6, 'TLS/SSL connection has been closed (EOF) 
    (_ssl.c:1002)')))
    ```

    **√â importante pontuar que, embora o erro diga que o n√∫mero m√°ximo de tentativas foi feita para uma determinada URL,
isso  aconteceu logo na primeira vez que tentei acessar o portal de 1¬∫ grau do TJCE.**

- A n√≠vel de organiza√ß√£o de c√≥digo, senti que manter todas minhas classes em um √∫nico ``models.py`` dificultava leitura
e manuten√ß√£o; ent√£o preferi separar cada classe em arquivos diferentes e agrup√°-las no diret√≥rio ``models``.

- Pretendia desenvolver um front-end interligado aos endpoints da API. Mas, como j√° havia passado um tempo desde que 
iniciei o desafio e precisei investir uma quantidade de tempo investigando os problemas descritos acima, optei por n√£o
faz√™-lo e focar apenas na constru√ß√£o da API. A constru√ß√£o de um font-end ficou para trabalhos futuros.
  
---

## ü§ì Coment√°rios gerais e solu√ß√µes adotadas

Inicialmente, pensei em desenvolver uma aplica√ß√£o de ponta a ponta, isto √©, incluindo tamb√©m um front-end.
Cogitei utilizar o Angular para tal, pois possuo algum conhecimento na cria√ß√£o de componentes. Mas, por outro lado,
n√£o tinha muita ideia de como construir um crawler usando TypeScript. 

Por isso, mesmo sendo um  framework que n√£o possuo grande familiaridade, optei pelo uso do Flask. Essa escolha me 
pareceu uma alternativa bastante vi√°vel por dois principais motivos:

1. O **Flask** √© um framework relativamente leve e poderia usar as rotas para a cria√ß√£o dos endpoints que lidaria com as
requisi√ß√µes. Al√©m disso, teria a possibilidade de criar tamb√©m um front-end; 

2. Possuo familiaridade com o Python e isso seria um ponto forte. Inclusive, por ter desenvolvido a solu√ß√£o de um outro
desafio de crawler (_Software Engineer Intern_, tamb√©m para Jusbrasil), poderia aproveitar os conhecimentos que adquiri 
com ele, especialmente sobre o **BeautifulSoup**. 

Apesar disso, desenvolver a solu√ß√£o acabou demandando um pouco mais de tempo do imaginei, pois al√©m de estar aprendendo
a utilizar algumas das tecnologias escolhidas (incluindo o Flask e o Selenium) durante o processo, encontrei problemas 
realizar requisi√ß√µes para o TJCE (esse talvez tenha sido meu maior desafio). Mais detalhes foram abordados na se√ß√£o 
_**Principais dificuldades**_.

- Para validar se os crawlers que desenvolvi eram capazes de obter os dados nos portais indicados, precisei procurar
outros n√∫meros de processos como exemplo e test√°-los.

- A fim de n√£o ficar mais tempo preso nos erros encontrados ao realizar requisi√ß√µes em busca de um processo de 1¬™ grau
no TJCE, precisei mockar uma p√°gina de exemplo para um n√∫mero de processo espec√≠fico a fim de validar o funcionamento do
crawler desenvolvido tamb√©m neste portal, pois para o TJAL o comportamento estava como esperado.

- Como enfrentei o mesmo problema ao acessar o portal de 2¬∫ grau do TJCE e, considerando ainda a presen√ßa de pop-ups que
tornariam o mock desses comportamentos um pouco mais complicado para mim, precisei adotar outro processo alternativo
para obter a p√°gina do processo buscado. Mais detalhes sobre isso ser√£o abordados nos t√≥picos abaixo.

- Simular as extra√ß√µes por meio de mocks deixaria a API limitada, pois s√≥ seria poss√≠vel extrair as informa√ß√µes para um
n√∫mero bastante limitado de exemplos. Al√©m disso, a presen√ßa de outros elementos interaivos (como os descritos acima) 
poderiam tornar o mock um pouco mais complexo. Ent√£o, precisei pensar em alguma alternativa para simular o acesso aos
portais (especialmente os do TJCE). Dessa forma, busquei automatizar o acesso aos portais com uso do Selenium. Apesar
de fazer com que as requisi√ß√µes levem mais tempo, especialmente quando realizadas para o TJCE (j√° que nesses cen√°rios 
o Selenium √© invocado para que possa ser obtida a p√°gina do processo), entendi que seria um trade-off necess√°rio e
valeria a pena para tornar a API mais pr√≥xima de um cen√°rio real. 

---

## üí¨ Sugest√µes

- Incluir exemplos de modelo de requisi√ß√£o e tamb√©m de retorno na descri√ß√£o do desafio poderia ser um bom norte de como
os dados poderiam ser tratados.

- Incluir algumas orienta√ß√µes de troubleshooting de acordo com feedbacks de outras pessoas candidatas. Por exemplo: mais
algu√©m teve problemas realizados a bloqueio de IP, SSL, etc.? Se sim, alguns exemplos de maneiras mais comuns ou 
indicadas de se contarnar essas situa√ß√µes seriam de grande ajuda.
